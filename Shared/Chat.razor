@implements IAsyncDisposable
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject IAuthService AuthService
@inject ILoggerFactory LoggerFactory
@inject IGameLogRepository GameLogRepo
@inject IGameRepository GameRepo
@inject IConfiguration Config;
@attribute [Authorize(Roles = "User")]
@using Microsoft.AspNetCore.SignalR.Client
@using System.Net.Http.Json
@using Microsoft.Extensions.Configuration


<PageTitle>Chat component</PageTitle>

@if (!GameFinished)
{
    <Rtc ParentGameId="@_parentGameId" />
    <div class="form-group">
        <label>
            Message:
            <input @bind="messageInput" type="text" />
        </label>
    </div>
    <button @onclick="SendTextMessage" disabled="@(!IsConnected)">Send</button>
}
<hr>

<ul id="messagesList">
    @foreach (var message in logLines)
    {
        <li>@message</li>
    }
</ul>

@code {
    private ILogger<Chat> logger = null!;
    private HubConnection? hubConnection;
    private List<string> logLines = new List<string>();
    private string? messageInput;
    private string? userMail;
    private string? token = null;

    [Parameter]
    public int GameId { get; set; }

    private string _parentGameId = String.Empty;

    [Parameter]
    public bool GameFinished { get; set; } = false;


    protected override async Task OnInitializedAsync()
    {
        logger = LoggerFactory.CreateLogger<Chat>();
        _parentGameId = (await GameRepo.GetParentGameId(GameId)).ToString();

        try
        {
            logLines = await GameLogRepo.GetGameLogLines(GameId);
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex.Message);
        }

        var state = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        userMail = state.User.Identity?.Name;

        if (!GameFinished)
        {
            var chatHubUrl = Config[SolutionPathes.HubUrl];
            hubConnection = new HubConnectionBuilder()
                .WithUrl(chatHubUrl!)
                .Build();

            hubConnection.On<int, string>("ReceiveMessage", async (RoomName, message) =>
            {
                await OnMessageFromServer(RoomName, message);
                StateHasChanged();

            });

            await hubConnection.StartAsync();
            StateHasChanged();
            await ConnectToRoom();
        }
        await base.OnInitializedAsync();

    }

    private async Task SendTextMessage()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("SendMessageToGroup", GameId, messageInput, userMail);
            messageInput = String.Empty;
        }
    }

    private async Task ConnectToRoom()
    {
        if (hubConnection is not null && GameId != 0)
        {
            await hubConnection.SendAsync("JoinRoom", GameId, userMail);
        }
    }

    public bool IsConnected =>
        hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("LeaveRoom", GameId, userMail);
            await hubConnection.StopAsync();
            await hubConnection.DisposeAsync();
        }
    }



    public async Task AddNewMessageToChatLog(string message)
    {
        LogLineDTOModel model = new()
            {
                GameId = GameId,
                Message = message
            };

        try
        {
            //TODO: якщо гра закінчена, заборонити користувачеві додавати нові записи в лог, а також записи про приєднання до гри
            await GameLogRepo.AddMessageToLog(model);
            logLines = await GameLogRepo.GetGameLogLines(GameId);
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex.Message);
        }

    }

    private async Task OnMessageFromServer(int roomName, string message)
    {
        var encodedMsg = $"{message} to room #{GameId}";
        await AddNewMessageToChatLog(encodedMsg);
        StateHasChanged();
    }
}